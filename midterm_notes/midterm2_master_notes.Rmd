---
title: "Midterm 2 Master Notes"
author: "Lejla Becirevic"
date: "2024-02-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(janitor)
library(skimr)
library(naniar)
library(visdat)
``` 

## LAB 8

**summarize() and group_by() are powerful tools that we can use to produce clean summaries of data. Especially when used together, we can quickly group variables of interest and save time**
```{r}
?penguins
```

**Produce a summary of the mean for bill_length_mm, bill_depth_mm, flipper_length_mm, and body_mass_g within Adelie penguins only. Be sure to provide the number of samples**
```{r}
penguins %>% 
  filter(species=="Adelie") %>% 
  summarize(mean_bill_length=mean(bill_length_mm, na.rm = T),
            mean_bill_depth=mean(bill_depth_mm, na.rm = T),
            mean_flippper_length=mean(flipper_length_mm, na.rm = T),
            mean_body_mass=mean(body_mass_g, na.rm = T),
            n=n())
```

### across()
**Function in dplyr called `across()` which can count for multiple variables**

**Use `summarize()` to produce distinct counts over multiple variables; i.e. species, island, and sex?** 
```{r}
penguins %>%
  summarize(distinct_species = n_distinct(species),
            distinct_island = n_distinct(island),
            distinct_sex = n_distinct(sex))
```

**By using `across()` we can reduce the clutter and make things cleaner**
```{r}
penguins %>%
  summarize(across(c(species, island, sex), n_distinct))
```

**This is very helpful for continuous variables**
```{r}
penguins %>%
  summarize(across(contains("mm"), mean, na.rm=T))
```

**group_by also works**
```{r}
penguins %>%
  group_by(sex) %>% 
  summarize(across(contains("mm"), mean, na.rm=T))
```

**Here we summarize across all variables**
```{r}
penguins %>%
  summarise_all(n_distinct)
```

**Operators can also work, here I am summarizing n_distinct() across all variables except species, island, and sex**
```{r}
penguins %>%
  summarize(across(!c(species, island, sex, year), 
                   mean, na.rm=T))
```

**All variables that include "bill"...all of the other dplyr operators also work**
```{r}
penguins %>%
  summarise(across(starts_with("bill"), n_distinct))
```

**Produce separate summaries of the mean and standard deviation for bill_length_mm, bill_depth_mm, and flipper_length_mm for each penguin species. Be sure to provide the number of samples**
```{r}
penguins %>% 
  group_by(species) %>% 
  summarise(across(c(contains("mm"), body_mass_g), mean, na.rm=T), #included variable after contains "mm" with the c() function, can also add stuff after
            n=n())
```

**Load the mammals life history data and clean the names**
```{r}
life_history <- read_csv("data/mammal_lifehistories_v3.csv") %>% clean_names()
```

**Here is a new one for you using the `purrr` package. This will give you a quick summary of the number of NA's in each variable.**
```{r}
life_history %>% 
  map_df(~ sum(is.na(.)))
```

**A single approach to deal with NA's in this data set**
```{r}
life_history <- read_csv("data/mammal_lifehistories_v3.csv", na= c("NA", " ", ".", "-999", "not measured")) %>% clean_names() # you nee to know how the NAs are represented in the data; you dont want to do this by default
```

### naniar
**naniar is a package that is built to manage NA's**

**miss_var_summary provides a clean summary of NA's across the data frame**
```{r}
naniar::miss_var_summary(life_history)
```

**Let's use mutate() and na_if() to replace 0's with NA's**
```{r}
life_history <- 
  life_history %>% 
  mutate(max_life=na_if(max_life, 0))
```

**We can also use `miss_var_summary` with `group_by()`. This helps us better evaluate where NA's are in the data.**
```{r}
life_history %>%
  group_by(order) %>%
  select(order, wean_mass) %>% 
  miss_var_summary(order=T)
```

**naniar also has a nice replace function which will allow you to precisely control which values you want replaced with NA's in each variable.**
```{r}
life_history %>% 
  replace_with_na(replace = list(newborn = "not measured", 
                                 weaning= -999, 
                                 wean_mass= -999, 
                                 afr= -999, 
                                 max_life= 0, 
                                 litter_size= -999, 
                                 gestation= -999, 
                                 mass= -999)) %>% 
miss_var_summary() #makes replacement of NAs specific with variable
```

**Import the data and do a little exploration. Be sure to clean the names if necessary.
```{r}
cites <- read_csv("data/cites.csv") %>% clean_names()
```

**Try using `group_by()` with `naniar`. Look specifically at class and `exporter_reported_quantity`. For which taxonomic classes do we have a high proportion of missing export data?**
```{r}
cites %>% 
  select(class, exporter_reported_quantity) %>% 
  group_by(class) %>%
  miss_var_summary() %>% 
  arrange(desc(pct_miss))
```

### Visualizing NAs
```{r}
vis_dat(life_history) #classes of data
```

```{r}
vis_miss(life_history)
```

### Dealing with NA's in advance
**If you are sure that you know how NA's are treated in the data, then you can deal with them in advance using `na()` as part of the `readr` package.**
```{r}
life_history_advance <- 
  readr::read_csv(file = "data/mammal_lifehistories_v3.csv", 
                  na = c("NA", " ", ".", "-999")) #all NA, blank spaces, .,and -999 are treated as NA
```


## LAB 9
### pivot_longer  
**Scientists frequently use spreadsheets that are organized to make data entry efficient. This is often referred to as wide format. Unfortunately, the wide format creates a problem because column names may actually represent values of a variable. The command `pivot_longer()` shifts data from wide to long format.**   

**Rules:** 
+ `pivot_longer`(cols, names_to, values_to)
+ `cols` - Columns to pivot to longer format
+ `names_to` - Name of the new column; it will contain the column names of gathered columns as values
+ `values_to` - Name of the new column; it will contain the data stored in the values of gathered columns

**Assess whether or not the data are tidy.**  
(1) each variable has its own column?  
(2) each observation has its own row? 
(3) each value has its own cell?  
  
**To fix this problem, we need to reshape the table to long format while keeping track of column names and values. We do this using `pivot_longer()`. Notice that the dimensions of the data frame change.**
```{r}
heartrate %>% 
  pivot_longer(-patient, #patient will not move
               names_to = "drug", #make a new column called "drug"
               values_to="heartrate" #values moved to a new column called "heartrate"
               )
```

**Examples**
Import the file `relig_income.csv` and store it as a new object `relig_income`.  
```{r}
relig_income <- read_csv("data/relig_income.csv")
```

Use `pivot_longer()` to make the data tidy.  
```{r}
relig_income %>% 
  pivot_longer(-religion,
               names_to = "income",
               values_to = "total")
```

Some (but not all) of the column names are data. We also have NA's.
```{r}
billboard <- read_csv("data/billboard.csv")
```

Solution 1: specify a range of columns that you want to pivot.
```{r}
billboard2 <- 
  billboard %>% 
  pivot_longer(wk1:wk76, # a range of columns
               names_to = "week",
               values_to = "rank", 
               values_drop_na = TRUE #this will drop the NA's
               )
```

Solution 2: OR, specify columns that you want to stay fixed.
```{r}
billboard3 <- 
  billboard %>% 
  pivot_longer(-c(artist, track, date.entered), #specific columns to stay fixed
               names_to = "week",
               values_to = "rank",
               values_drop_na = TRUE
               )
```

Solution 3: identify columns by a prefix, remove the prefix and all NA's.
```{r}
billboard %>% 
   pivot_longer(
   cols = starts_with("wk"), #columns that start with "wk"
   names_to = "week",
   names_prefix = "wk",
   values_to = "rank",
   values_drop_na = TRUE)
```

Import `plant_data.csv` as a new object `plant_data`.  
```{r}
plant_data <- read_csv("data/plant_data.csv")
```

Use `pivot_longer()` to make the data tidy. Focus the data only on genotype, water_sched_prog, and greenhouse.  
```{r}
plant_data %>% 
  pivot_longer(-c(genotype, water_sched_prog, greenhouse),
               names_to = "day",
               values_to = "v2",
               values_drop_na = TRUE)
```

Recall that we use `pivot_longer()` when our column names actually represent variables. A classic example would be that the column names represent observations of a variable.
```{r}
datasets::USPersonalExpenditure
?USPersonalExpenditure
```

Here we add a new column of expenditure types, which are stored as rownames above, with `mutate()`. The `USPersonalExpenditures` data also needs to be converted to a data frame before we can use the tidyverse functions, because it comes as a matrix.
```{r}
expenditures <- USPersonalExpenditure %>% 
  as_tibble() %>% #this transforms the matrix into a data frame
  mutate(expenditure = rownames(USPersonalExpenditure))
expenditures
```

## Practice
1. Are these data tidy? Please use `pivot_longer()` to tidy the data.
```{r}
expenditures %>% 
  pivot_longer(-expenditure, #not moving expenditure 
               names_to = "year", #make new variable = year
               values_to = "bn_dollars") #moving values into bn_dollars
```

2. Restrict the data to medical and health expenditures only. Sort in ascending order.
```{r}
expenditures %>% 
  pivot_longer(-expenditure,
               names_to = "year",
               values_to = "bn_dollars") %>% 
  filter(expenditure=="Medical and Health") %>% 
  arrange(-bn_dollars)
```

```{r}
expenditures %>% 
  pivot_longer(-expenditure,
               names_to = "year",
               values_to = "bn_dollars") %>% 
  filter(expenditure=="Private Education") 
```

### names_sep 
**Helps pull these apart, but we still have "exp" and "rep" to deal with.**  
```{r}
qpcr_untidy %>% 
  pivot_longer(
    exp1_rep1:exp3_rep3, #range
    names_to= c("experiment", "replicate"), #names of columns
    names_sep="_", #separate by _
    values_to="mRNA_expression")
```

### separate
In this new heart rate example, we have the sex of each patient included with their name. Are these data tidy? No, there is more than one value per cell in the patient column and the columns a, b, c, d once again represent values.
```{r}
heartrate2 <- read_csv("data/heartrate2.csv")
heartrate2
```

We need to start by separating the patient names from their sexes. `separate()` needs to know which column you want to split, the names of the new columns, and what to look for in terms of breaks in the data.
```{r}
heartrate2 %>% 
  separate(patient, into= c("patient", "sex"), sep = "_") #seperate patient from sex with the _
```

## Practice
1. Re-examine `heartrate2`. Use `separate()` for the sexes, `pivot_longer()` to tidy, and `arrange()` to organize by patient and drug. Store this as a new object `heartrate3`.  
```{r}
heartrate3 <- heartrate2 %>% 
  separate(patient, into=c("patient", "sex"), sep="_") %>% 
  pivot_longer(-c(patient, sex),
               names_to = "drug",
               values_to = "heartrate")
heartrate3
```

### unite
**Opposite of separate(). Its syntax is straightforward. You only need to give a new column name and then list the columns to combine with a separation character.  Give it a try below by recombining patient and sex from `heartrate3`.**
```{r}
heartrate3 %>% 
  unite(patient_sex, "patient", "sex", sep=" ") #does the opposite, takes two variables and combines
```

### pivot_wider
The opposite of `pivot_longer()`. You use `pivot_wider()` when you have an observation scattered across multiple rows. In the example below, `cases` and `population` represent variable names not observations.  

Rules:  
+ `pivot_wider`(names_from, values_from)  
+ `names_from` - Values in the `names_from` column will become new column names  
+ `values_from` - Cell values will be taken from the `values_from` column  

```{r}
tb_data <- read_csv("data/tb_data.csv") #value column is not represented of single variable 
tb_data
```

When using `pivot_wider()` we use `names_from` to identify the variables (new column names) and `values_from` to identify the values associated with the new columns.
```{r}
tb_data %>% 
  pivot_wider(names_from = "key", #the observations under key will become new columns
              values_from = "value") #the values under value will be moved to the new columns
```

## Practice
1. Load the `gene_exp.csv` data as a new object `gene_exp`. Are these data tidy? Use `pivot_wider()` to tidy the data.
```{r}
gene_exp <- read_csv("data/gene_exp.csv")
gene_exp
```

```{r}
gene_exp %>% 
  pivot_wider(names_from = "type",
              values_from = "L4_values")
```

## Practice
For the last practice example, I will use data from the awesome [R Ladies Sydney](https://rladiessydney.org/courses/ryouwithme/02-cleanitup-5/) blog. This data set is compiled by the NSW Office of Environment and Heritage contains the enterococci counts in water samples obtained from Sydney beaches as part of the Beachwatch Water Quality Program! The data set weâ€™ll be working with is current as of October 13th 2018.  

1. Load the beachbugs data and have a look.
```{r}
beachbugs <- read_csv("data/beachbugs_long.csv")
beachbugs
```

2. Use `pivot_wider` to transform the data into wide format.
```{r}
beachbugs_wide <- beachbugs %>% 
  pivot_wider(names_from = site,
              values_from = buglevels)
beachbugs_wide
```

3. Now, use `pivot_longer` to transform them back to long!
```{r}
beachbugs_wide %>% 
  pivot_longer(-year,
               names_to = "site",
               values_to = "buglevels") %>% 
  arrange(desc(buglevels))
```

